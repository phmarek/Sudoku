(defparameter *board* (make-array '(8 9) :initial-element 0))

(defparameter *columns* (make-array 9 :initial-element 6))

(defun possibilities ()
  (loop for i from 1 to 7
	when (plusp (aref *columns* i))
	collect i))

(defun make-move (column color)
  (setf (aref *board* (aref *columns* column) column) color)
  (decf (aref *columns* column)))

(defun unmake-move (column)
  (incf (aref *columns* column))
  (setf (aref *board* (aref *columns* column) column) 0))

(defun four-in-a-row-p (column)
  (let* ((row (1+ (aref *columns* column)))
	 (color (aref *board* row column))
	 (count 1))
    (loop for c downfrom (1- column)
	  while (eql (aref *board* row c) color)
	  do (incf count))
    (loop for c from (1+ column)
	  while (eql (aref *board* row c) color)
	  do (incf count))
    (when (>= count 4)
      (return-from four-in-a-row-p t))
    (setf count 1)
    (loop for r downfrom (1- row)
	  while (eql (aref *board* r column) color)
	  do (incf count))
    (loop for r from (1+ row)
	  while (eql (aref *board* r column) color)
	  do (incf count))
    (when (>= count 4)
      (return-from four-in-a-row-p t))
    (setf count 1)
    (loop for r downfrom (1- row)
	  for c downfrom (1- column)
	  while (eql (aref *board* r c) color)
	  do (incf count))
    (loop for r from (1+ row)
	  for c from (1+ column)
	  while (eql (aref *board* r c) color)
	  do (incf count))
    (when (>= count 4)
      (return-from four-in-a-row-p t))
    (setf count 1)
    (loop for r downfrom (1- row)
	  for c from (1+ column)
	  while (eql (aref *board* r c) color)
	  do (incf count))
    (loop for r from (1+ row)
	  for c downfrom (1- column)
	  while (eql (aref *board* r c) color)
	  do (incf count))
    (when (>= count 4)
      (return-from four-in-a-row-p t))
    nil))
    
(defparameter *board-count* 0)

(defun increase-board-count ()
  (when (zerop (mod (incf *board-count*) 1000000))
    (pprint *board-count* *trace-output*)
    (finish-output *trace-output*))
  (when (zerop (mod *board-count* 10000000))
    (print *board* *trace-output*)
    (finish-output *trace-output*)))

(defun doit (color)
  (let ((possibilities (possibilities)))
    (loop for column in possibilities
	  do (progn (make-move column color)
		    (when (four-in-a-row-p column)
		      (unmake-move column)
		      (return-from doit color))
		    (unmake-move column)))
    (loop for column in possibilities
	  do (progn (increase-board-count)
		    (make-move column color)
		    (doit (- 3 color))
		    (unmake-move column)))))
	
(defun fact (n)
  (if (zerop n) 1 (* n (fact (1- n)))))

(defun choose (n p)
  (/ (fact n) (fact p) (fact (- n p))))

(defun smallest (x n max)
  (max 0 (- x (* max (1- n)))))

(defun divide-into-n (x n max)
  (cond ((= n 1) 1)
	(t (loop for i from (smallest x n max) to (min x max)
		 sum (divide-into-n (- x i) (1- n) max)))))
  